30/08/22
Club Automation
Projects-
1. Lights on(/using voice command)(1-1.5 months)
2. Door lock system(1.5 month)
3. Sensor slabs (for components)
4. AC control
If any other idea for project comes up , pls share 
To be completed by November end.

03/10/2022
Club Automation
Minutes
1. Slab location detection using qr code.
2. Lights on/off  miniature model using relays.
Or
1 sensor inside and 1 sensor outside keeping track of person entering or leaving the room and switch on/off lights accordingly 
3. Ac on/off controller using servo motor based on off remote. Or
2 sensors 1 inside and 1 outside to maintain inside temperature based on outside temperature.
4. Rfid door lock materials released.

13/10/2022
Club Automations
Minutes
1. Discussion about the sensor slab project using QR code reader and IR Sensor.
2. Introductory teaching on how the IR Sensor works. A sample code for the same was discussed.

Sample Code:

int IRSensor = 2;                   // connect IR Sensor to Arduino pin 2
int LED = 13;                       // conect LED to Arduino pin 13
void setup() {
  Serial.begin(9600);  
  pinMode (IRSensor, INPUT);        // sensor pin INPUT
  pinMode (LED, OUTPUT);            // Led pin OUTPUT
}
void loop(){
  int statusSensor = digitalRead (IRSensor);
  if (statusSensor == 1){
    digitalWrite(LED, LOW);         // LED LOW or LED OFF when nothing is in front of IR Sensor
  }else{
    digitalWrite(LED, HIGH);        // LED High or LED ON when an object is brought near the IR Sensor
  }
 }

 3. A brief introduction to RPI Microcontroller.
 
 
 22/10/2022
 Club Automation
 Minutes:
  1.Finalized the project.
  2.Will start doing the basic model from Tuesday(25/10/2022).
  3.Learn about basics of arduino if you already dont know and also about the mic module.



04/11/22
Club Automation project made by Swati and Gourab
Minutes:
1.Made a circuit for RFID door lock.
2.Solonoid lock was not working with battery so we use multimeter.
3.Run the code for scanning the ID card.
4.Run the code for scanning the RFID door lock.


13/11/22
Club Automation
Minutes:
1.RFID card: read and write 
2.Read and write code:#include <SPI.h>      //include the SPI bus library
#include <MFRC522.h>  //include the RFID reader library

#define SS_PIN 10  //slave select pin
#define RST_PIN 5  //reset pin

MFRC522 mfrc522(SS_PIN, RST_PIN);  // instatiate a MFRC522 reader object.
MFRC522::MIFARE_Key key;          //create a MIFARE_Key struct named 'key', which will hold the card information

//this is the block number we will write into and the
int block1=1;
int block2 =2;
int block3=5;
int block4 = 6;
byte blockcontent[16] = {"shubham_jaiswal"};
byte blockcontent1[16] = {"210106066"};
byte blockcontent2[16] = {"swati__sinha"};
byte blockcontent3[16] = {"210102061"};
//an array with 16 bytes to be written into one of the 64 card blocks is defined
//byte blockcontent[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  //all zeros. This can be used to delete a block.

//This array is used for reading out a block.
byte readbackblock[18];

void setup() 
{
    Serial.begin(9600);        // Initialize serial communications with the PC
    SPI.begin();               // Init SPI bus
    mfrc522.PCD_Init();        // Init MFRC522 card (in case you wonder what PCD means: proximity coupling device)
    Serial.println("Scan a MIFARE Classic card");
  
  // Prepare the security key for the read and write functions.
  for (byte i = 0; i < 6; i++) {
    key.keyByte[i] = 0xFF;  //keyByte is defined in the "MIFARE_Key" 'struct' definition in the .h file of the library
  }
}

void loop()
{  
  // Look for new cards
  if ( ! mfrc522.PICC_IsNewCardPresent()) {
    return;
  }
  
  // Select one of the cards
  if ( ! mfrc522.PICC_ReadCardSerial()) 
  {
    return;
  }
    Serial.println("card selected");
         
   //the blockcontent array is written into the card block
   writeBlock(block1, blockcontent);
   writeBlock(block2, blockcontent1);
   writeBlock(block3, blockcontent2);
   writeBlock(block4, blockcontent3);
   //read the block back
   readBlock(block1, readbackblock);
   //uncomment below line if you want to see the entire 1k memory with the block written into it.
   //mfrc522.PICC_DumpToSerial(&(mfrc522.uid));
   
//   print the block contents
   Serial.print("read block: ");
   for (int j=0 ; j<16 ; j++)
   {
     Serial.write (readbackblock[j]);
   }

   readBlock(block2, readbackblock);
   
   Serial.print("read block: ");
   for (int j=0 ; j<16 ; j++)
   {
     Serial.write (readbackblock[j]);
   }
   
   readBlock(block3, readbackblock);
   Serial.print("read block: ");
   for (int j=0 ; j<16 ; j++)
   {
     Serial.write (readbackblock[j]);
   }

   readBlock(block4, readbackblock);
   
   Serial.print("read block: ");
   for (int j=0 ; j<16 ; j++)
   {
     Serial.write (readbackblock[j]);
   }
   
   Serial.println("");
}



//Write specific block    
int writeBlock(int blockNumber, byte arrayAddress[]) 
{
  //this makes sure that we only write into data blocks. Every 4th block is a trailer block for the access/security info.
  int largestModulo4Number=blockNumber/4*4;
  int trailerBlock=largestModulo4Number+3;//determine trailer block for the sector
  if (blockNumber > 2 && (blockNumber+1)%4 == 0){Serial.print(blockNumber);Serial.println(" is a trailer block:");return 2;}
  Serial.print(blockNumber);
  Serial.println(" is block number:");
  
  //authentication of the desired block for access
  byte status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, &key, &(mfrc522.uid));
  if (status != MFRC522::STATUS_OK) {
         Serial.print("PCD_Authenticate() failed: ");
         Serial.println(mfrc522.GetStatusCodeName(status));
         return 3;//return "3" as error message
  }
//  
  //writing the block 
  status = mfrc522.MIFARE_Write(blockNumber, arrayAddress, 16);
  //status = mfrc522.MIFARE_Write(9, value1Block, 16);
  if (status != MFRC522::STATUS_OK) {
           Serial.print("MIFARE_Write() failed: ");
           Serial.println(mfrc522.GetStatusCodeName(status));
           return 4;//return "4" as error message
  }
  Serial.println("block was written");
}



//Read specific block
int readBlock(int blockNumber, byte arrayAddress[]) 
{
  int largestModulo4Number=blockNumber/4*4;
  int trailerBlock=largestModulo4Number+3;//determine trailer block for the sector

  //authentication of the desired block for access
  byte status = mfrc522.PCD_Authenticate(MFRC522::PICC_CMD_MF_AUTH_KEY_A, trailerBlock, &key, &(mfrc522.uid));

  if (status != MFRC522::STATUS_OK) {
         Serial.print("PCD_Authenticate() failed (read): ");
         Serial.println(mfrc522.GetStatusCodeName(status));
         return 3;//return "3" as error message
  }

//reading a block
byte buffersize = 18;//we need to define a variable with the read buffer size, since the MIFARE_Read method below needs a pointer to the variable that contains the size... 
status = mfrc522.MIFARE_Read(blockNumber, arrayAddress, &buffersize);//&buffersize is a pointer to the buffersize variable; MIFARE_Read requires a pointer instead of just a number
  if (status != MFRC522::STATUS_OK) {
          Serial.print("MIFARE_read() failed: ");
          Serial.println(mfrc522.GetStatusCodeName(status));
          return 4;//return "4" as error message
  }
  Serial.println("block was read");
}
3.Memory display code:
#include <SPI.h>
#include <MFRC522.h>

#define RST_PIN         9          // Configurable, see typical pin layout above
#define SS_PIN          10         // Configurable, see typical pin layout above

MFRC522 mfrc522(SS_PIN, RST_PIN);  // Create MFRC522 instance

void setup() {
	Serial.begin(9600);		// Initialize serial communications with the PC
	while (!Serial);		// Do nothing if no serial port is opened (added for Arduinos based on ATMEGA32U4)
	SPI.begin();			// Init SPI bus
	mfrc522.PCD_Init();		// Init MFRC522
	delay(4);				// Optional delay. Some board do need more time after init to be ready, see Readme
	mfrc522.PCD_DumpVersionToSerial();	// Show details of PCD - MFRC522 Card Reader details
	Serial.println(F("Scan PICC to see UID, SAK, type, and data blocks..."));
}

void loop() {
	// Reset the loop if no new card present on the sensor/reader. This saves the entire process when idle.
	if ( ! mfrc522.PICC_IsNewCardPresent()) {
		return;
	}

	// Select one of the cards
	if ( ! mfrc522.PICC_ReadCardSerial()) {
		return;
	}

	// Dump debug info about the card; PICC_HaltA() is automatically called
	mfrc522.PICC_DumpToSerial(&(mfrc522.uid));
}
